# JWT

JWT is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting info between parties as a JSON object. This info can be verified and trusted because it is digitally signed. Can be signed using a secret (HMAC algo) or a public/private key pair using RSA or ECDSA.

Signed tokens can verify the _integrity_ of the claims contained within it, while encrypted tokens _hide_ those claims from other parties.

JWT tokens are popular as they are used as the default token format in new authorization and authentication protocols like OAuth 2.0 and OpenID Connect.

- JWT is the de-factor standard for authenticating Backend APIs
- token that is used to authenticate and authorize users in an application
  - **authenticate**: who they are
  - **authorize**: what they can access
- token itself contains all the necessary information about the user, like ID and role, in a JSON
- tokens are typically generated by the server and send to the client after a successful login
  - client can use JWT with each request to authenticate and authorize itself to the server
- JWT has three parts:
  - header: type of token, signing algorithm (HMAC, SHA256, RSA)
  - payload: claims (statements about an entity, typically the user) and additional metadata
    - claims are typically represented as key-value pairs and can include information such as the user's ID, name, email, and roles
  - signature: used to verify that the sender of the JWT is who it says it is and to ensure that the message has not been tampered with

## When should you use JWTs?

1. Authorization: once user is logged in, each subsequent request will include the JWT, allowing user to access routes, services, and resources that are permitted with those tokens
2. Information exchange

## What is the JWT structure?

`<base64-encoded-header>.<base64-encoded-payload>.<base64-encoded-signature>`

### Header

```json
{
  "alg": "HS256", // algorithm (HMAC, SHA256, RSA) used to sign token
  "typ": "JWT" // specifies that this is a JWT token
}
```

### Payload

The payload contains the claims, which are statements about an entity (typically, the user) and additional data. Three types of claims:

- **registered** claims: predefined claims that are recommended such as **iss** (issuer), **exp** (expiration time - UNIX), **sub** (subject), **aud** (audience), etc.
- **public** claims
- **private** claims

An example payload could be:

```json
{
  "sub": "1234567890",
  "name": "John Doe",
  "admin": true
}
```

### Signature

To create the signature part, you have to take the encoded header, encoded payload, a secret, the algorithm specified in header, and sign that.

```
HMACSHA256(
  base64UrlEncode(header) + "." +
  base64UrlEncode(payload),
  secret
)
```

The signature is used to verify the message wasn't changed along the way, and in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is. The signature's secret key is held by the server so it will be able to verify existing tokens.

## Advantages of token-based approach

- allows us to make AJAX calls to any server or domain since the HTTP header is used to transmit user info
- no need for having a separate session store on the server → JWT itself conveys entire info
- server side reduces to just an API
- authentication system is mobile ready
- eliminating cookies means no more need to protect against cross site requests
- JWT can be self-issued or an external service can issue it with allowed scopes and expiration

## How do JWTs work?

1. client → make a POST request with username and password
2. server → creates a web token and returns it to browser
3. client → sends token in Authorization headers with request to a restricted resource
4. server → validates token and sends response to client

In authentication, when user successfully logs in using credentials, a JWT will be returned. Since tokens are credentials, great care must be taken to prevent security issues. In general, you should not keep tokens longer than required. You should not store sensitive session data in browser storage due to lack of security.

Whenever the user wants to access a protected route or resource, the user agent should send the JWT, typically in the **Authorization** header using the **Bearer** schema.

```
Authorization: Bearer <token>
```

This can be, in certain cases, a stateless authorization mechanism. The server's protected routes will check for a valid JWT in the `Authorization` header, and if present, the user will be allowed to access protected resources.

If the token is sent in the `Authorization` header, Cross-Origin Resource Sharing (CORS) won't be an issue as it doesn't use cookies.

1. The app or client requests authorization to the authorization server. For example, a typical OpenID Connect compliant web app will go through the `/oauth/authorize` endpoint using the authorization code flow.
2. When authorization is granted, authorization server returns an access token to the app.
3. The app uses the access token to access a protected resource (like an API).

Note that with signed tokens, all the information contained within the token is exposed to users or other parties, even though they are unable to change it. This means you should not put secret information within the token unless it is encrypted.

## Security Concerns

When handling JWTs, prevent them from getting stolen, and set short expiry times in case they do get stolen.

It's important not to store JWT on the client (cookies, localstorage) because it will make your app vulnerable to CSRF and XSS attacks.

Serialized form of JWT:

`base64UrlEncode(header).base64UrlEncode(payload).signature`

A JWT is not encrypted. It is base64 encoded and signed. So anyone can decode the token and use its data. A JWT's signature is used to verify that it is in fact from a legitimate source.

App:

1. login/signup request to auth server/endpoint(`/login`)
   - JWT token is generated and signed using header algorithm and secret
   - token in serialized form is sent back to app
2. app makes an API call (`/api`), passing in token in header
   - API/microservice verifies that token is from legitimate source
   - get claims data, do business logic, return data

### Storing JWTs Securely in Frontend

https://dev.to/cotter/localstorage-vs-cookies-all-you-need-to-know-about-storing-jwt-tokens-securely-in-the-front-end-15id

**Access tokens** are usually short-lived JWT tokens, signed by your server, and are included in every HTTP request to your server to authorize the request

**Refresh tokens** are usually long-lived opaque strings stored in your database and are used to get a new access token when it expires

#### Where should I store my tokens in the frontend?

Local storage is vulnerable to XSS attacks. An XSS attack happens when an attacker can run JS on your website. This means the attacker can just take the access token that you stored in your `localStorage`. An XSS attack can happen from 3rd party JS code included in your website.

If using `httpOnly` and `secure` cookies, your cookies cannot be accessed using JS. This means, even if an attacker can run JS on your site, they can't read your access token from the cookie.

However, attackers can just send an HTTP request to your server, and that will automatically include your cookies. It's just less convenient for the attacker because they can't read the content of the token although they rarely have to.

A CSRF attack is an attack that forces a user to do an unintended request. An attacker can make a `form` in a malicious website that sends a POST request to your site, and the cookie will automatically be included. However, this can be mitigated by using `sameSite` flag in your cookie and by include an anti-CSRF token (?).

#### Store your access token in memory and store your refresh token in the cookie.

Why is this safe from CSRF?

Although a form submit to `/refresh_token` will work and a new access token will be returned, the attack can't read the response if they're using an HTML form. To prevent the attacker from successfully making a `fetch` or `AJAX` request and read the response, this requires the Authorization Server's CORS policy to be set up correctly to prevent requests from unauthorized websites.

1. Return access token and refresh token when user is authenticated

   After user is authenticated, the Authorization Server will return an `access_token` and a `refresh_token`. The `access_token` will be included in the response body and the `refresh_token` will be included in the cookie.

   Refresh token cookie setup:

   - `httpOnly`: prevent JS from reading it
   - `secure=true`: can only be sent over HTTPS
   - `SameSite=strict`: to prevent CSRF; can only be used if the Authorization Server has same site as your frontend; if not, your Authorization Server must set your CORS headers in the backend or use other methods to ensure that the refresh token request can only be done by authorized websites

2. Store the access token in memory

   Storing the token in-memory means that you put this access token in a variable in your front-end site. This means the access token will be gone if the user switches tabs or refreshes the site. That's why we have the refresh token.

3. Renew access token using the refresh token

   When the access token is gone or has expired, hit the `/refresh_token` endpoint and the refresh token that was stored in cookie in step 1 will be included in the request - you will get a new access token an can then use that for your API requests. This means your JWT token can be larger than 4kb and you can also put it in the Authorization header.

### CRSF problem

When the _token is stored in a cookie_, the browser will _automatically send it along with each request_ to the same domain. This is still vulnerable to CSRF attacks.

Bearer authentication is one of the authentication schemes defined in HTTP. It basically means that **you** stick the JWT in the Authorization HTTP header of a request. The browser will NOT do this automatically, so it's not suitable for protecting your website. As the browser does not automatically add the header to your request, it is not vulnerable to CSRF attack. The bearer scheme is often used to protect web APIs (REST services).

**Storing the JWT on client computer**. If we store it in local storage, it can easily be grabbed by a XSS attack. If we store it in cookies, it can be used (without reading it) in a CSRF attack and impersonate the user and contact our API and send requests to do actions or get information on behalf of a user.

To solve the CSRF problem, **double submit cookies**.

- Store JWT in a HttpOnly cookie, and use it in secure mode to transfer over HTTPS.
- Most CSRF attacks have a different origin or referrer header with your original host in their requests. Check if you have any of them in the header - are they coming from your domain or not? If both origin and referrer are not available in request, you can check result of X-XSRF-TOKEN header (see below).
- While browser will automatically supply cookies for domain of request, the JS code that is running on a website cannot read cookies of other websites. To prevent CSRF attacks, we must create an extra JS readable cookie which is called: XSRF-TOKEN. This cookie must be created when user is logged in and should contain a random, un-guessable string. We also save this number in the JWT itself as a private claim. Everytime the JS application wants to make a request, it will need to read this token and send it along in a custom HTTP header. Because these operations (reading the cookie, setting the header) can only be done on the same domain of the JS app, we can know that this is being done by a real user who is using our JS app.
